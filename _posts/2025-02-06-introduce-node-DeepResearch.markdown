---
layout: single
title: "ðŸš€é›¶æˆæœ¬å¤åˆ»Deep Researchï¼è¶…è¶ŠOpenAI Deep Research+DeepSeek R1ï¼ä¸‰åˆ†é’Ÿå¿«é€Ÿéƒ¨ç½²node-DeepResearchæœ€å¼ºAI agentï¼Œç”±Jina AIæ‰“é€ ï¼"
sidebar:
  nav: "docs"
date: 2025-02-06 00:00:00 +0800
categories: AIAgents
tags: [AIæ™ºèƒ½ä½“, node-DeepResearch, DeepResearch, AI agent, AI agents]
classes: wide
author_profile: true
---

Jina AI å¼€å‘çš„ **node-DeepResearch** æ˜¯ä¸€ä¸ªå¼€æºè‡ªåŠ¨åŒ–ç ”ç©¶å·¥å…·ï¼Œæ—¨åœ¨é€šè¿‡æœç´¢ã€é˜…è¯»ç½‘é¡µå’ŒæŽ¨ç†ï¼Œç›´åˆ°æ‰¾åˆ°é—®é¢˜çš„ç­”æ¡ˆã€‚è¯¥é¡¹ç›®é€‚ç”¨äºŽè‡ªåŠ¨åŒ–ä¿¡æ¯æ£€ç´¢å’Œæ™ºèƒ½é—®ç­”ä»»åŠ¡ï¼Œç»“åˆäº†æœç´¢å¼•æ“Žå’Œå¤§è¯­è¨€æ¨¡åž‹ï¼ˆLLMï¼‰æ¥æé«˜ç ”ç©¶æ•ˆçŽ‡ã€‚

### **æœ¬ç¯‡ç¬”è®°æ‰€å¯¹åº”çš„è§†é¢‘ï¼š**

- [ðŸ‘‰ðŸ‘‰ðŸ‘‰ é€šè¿‡å“”å“©å“”å“©è§‚çœ‹](https://www.bilibili.com/video/BV1CXPCecEUk/)
- [ðŸ‘‰ðŸ‘‰ðŸ‘‰ é€šè¿‡YouTubeè§‚çœ‹](https://youtu.be/vrpraFiPUyA)
- [ðŸ‘‰ðŸ‘‰ðŸ‘‰ æˆ‘çš„å¼€æºé¡¹ç›®](https://github.com/win4r/AISuperDomain)
- [ðŸ‘‰ðŸ‘‰ðŸ‘‰ è¯·æˆ‘å–å’–å•¡](https://ko-fi.com/aila)
- ðŸ‘‰ðŸ‘‰ðŸ‘‰ æˆ‘çš„å¾®ä¿¡ï¼šstoeng ã€åŠ æˆ‘è¯·æ³¨æ˜Žæ¥æ„ã€‘
- ðŸ‘‰ðŸ‘‰ðŸ‘‰ æ‰¿æŽ¥å¤§æ¨¡åž‹å¾®è°ƒã€RAGã€AIæ™ºèƒ½ä½“ã€AIç›¸å…³åº”ç”¨å¼€å‘ç­‰é¡¹ç›®ã€‚


### ðŸš€OpenAI Deep Researchç®€ä»‹ï¼š

OpenAIæœ€è¿‘æŽ¨å‡ºäº†Deep ResearchåŠŸèƒ½ï¼Œé€šè¿‡è‡ªåŠ¨åŒ–çš„å¤šæ­¥éª¤äº’è”ç½‘ç ”ç©¶ä»»åŠ¡ï¼Œç”Ÿæˆå…¨é¢çš„æŠ¥å‘Šã€‚

è¯¥åŠŸèƒ½åˆ©ç”¨æœ€æ–°çš„o3æ¨¡åž‹ï¼Œèƒ½å¤Ÿåˆ†æžå’Œç»¼åˆæ¥è‡ªå„ç§åœ¨çº¿æ¥æºçš„æ•°æ®ï¼ŒåŒ…æ‹¬æ–‡æœ¬ã€å›¾åƒå’ŒPDFã€‚

ç”¨æˆ·åªéœ€æä¾›ä¸€ä¸ªæç¤ºï¼ŒChatGPTå°±ä¼šåœ¨10åˆ†é’Ÿå†…ç”Ÿæˆä¸€ä»½è¯¦ç»†çš„æŠ¥å‘Šã€‚

Deep Researchåœ¨Humanity's Last ExamåŸºå‡†æµ‹è¯•ä¸­å–å¾—äº†26.6%çš„å¾—åˆ†ï¼Œæ˜¾ç¤ºäº†å…¶åœ¨å¤„ç†å¤æ‚ç ”ç©¶ä»»åŠ¡æ–¹é¢çš„èƒ½åŠ›ã€‚

ç›®å‰ï¼ŒDeep Researchå·²é›†æˆåˆ°ChatGPTç•Œé¢ä¸­ï¼Œä¾›ç¾Žå›½çš„Proè®¢é˜…ç”¨æˆ·ä½¿ç”¨ã€‚

æ‰€ä»¥æˆ‘ä»¬ä½¿ç”¨å¼€æºçš„**Jina AI node-DeepResearch**æ›¿ä»£æ–¹æ¡ˆæ¥å¤çŽ°Deep Researchã€‚

### **ðŸš€Jina AI node-DeepResearch ç®€ä»‹**

Jina AI å¼€å‘çš„ **node-DeepResearch** æ˜¯ä¸€ä¸ªå¼€æºè‡ªåŠ¨åŒ–ç ”ç©¶å·¥å…·ï¼Œæ—¨åœ¨é€šè¿‡æœç´¢ã€é˜…è¯»ç½‘é¡µå’ŒæŽ¨ç†ï¼Œç›´åˆ°æ‰¾åˆ°é—®é¢˜çš„ç­”æ¡ˆã€‚è¯¥é¡¹ç›®é€‚ç”¨äºŽè‡ªåŠ¨åŒ–ä¿¡æ¯æ£€ç´¢å’Œæ™ºèƒ½é—®ç­”ä»»åŠ¡ï¼Œç»“åˆäº†æœç´¢å¼•æ“Žå’Œå¤§è¯­è¨€æ¨¡åž‹ï¼ˆLLMï¼‰æ¥æé«˜ç ”ç©¶æ•ˆçŽ‡ã€‚

### **ä¸»è¦åŠŸèƒ½**

- **è‡ªåŠ¨æœç´¢å’ŒæŽ¨ç†**ï¼šä½¿ç”¨æœç´¢å¼•æ“ŽæŸ¥æ‰¾ç›¸å…³ç½‘é¡µï¼Œå¹¶é€šè¿‡å¤§æ¨¡åž‹ï¼ˆå¦‚ Geminiï¼‰æŽ¨ç†ï¼Œç”Ÿæˆæœ€ç»ˆç­”æ¡ˆã€‚
- **æ™ºèƒ½ç½‘é¡µé˜…è¯»**ï¼šç»“åˆ Jina Readerï¼Œèƒ½å¤Ÿä»Žç½‘é¡µæå–å…³é”®å†…å®¹ï¼Œæå‡ä¿¡æ¯èŽ·å–çš„ç²¾å‡†åº¦ã€‚
- **å¯é…ç½® API**ï¼šç”¨æˆ·å¯é…ç½®è‡ªå·±çš„ **Gemini API** å’Œ **Jina Reader API**ï¼Œä»¥ä¼˜åŒ–æŸ¥è¯¢æ•ˆæžœã€‚

**âœ…Jina AI node-DeepResearch GitHubä»“åº“** [https://github.com/jina-ai/node-DeepResearch](https://github.com/jina-ai/node-DeepResearch)

### ðŸš€çŽ¯å¢ƒé…ç½®

1ï¸âƒ£Node.jsé…ç½®

> **Windows**ç”¨æˆ·åªéœ€è¦æ‰“å¼€é“¾æŽ¥ä¸‹è½½å¯¹åº”ç‰ˆæœ¬çš„Node.jså®‰è£…åŒ…å®‰è£…å³å¯
é“¾æŽ¥ï¼š[https://nodejs.org/en/download](https://nodejs.org/en/download)

**Linuxå®‰è£…æ–¹å¼ï¼š**
`curl -o- [https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.2/install.sh](https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.2/install.sh) | bash
source ~/.bashrc
nvm install --lts`

macOSå®‰è£…æ–¹å¼ï¼š
`/bin/bash -c "$(curl -fsSL [https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh](https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh))"
brew install node`

æ‰“å¼€ç»ˆç«¯å‘½ä»¤è¡Œï¼Œè¾“å…¥`node -v`å’Œ`npm -v`éªŒè¯å®‰è£…
> 

2ï¸âƒ£Gitå®‰è£…

> æ‰“å¼€é“¾æŽ¥ä¸‹è½½å¯¹åº”çš„å®‰è£…åŒ…è¿›è¡Œå®‰è£…å³å¯
é“¾æŽ¥ï¼š[https://git-scm.com/downloads](https://git-scm.com/downloads)
éªŒè¯ï¼š`git --version`
> 

3ï¸âƒ£Python3å®‰è£…

> æ‰“å¼€é“¾æŽ¥ä¸‹è½½å¯¹åº”ç‰ˆæœ¬çš„Node.jså®‰è£…åŒ…å®‰è£…å³å¯
é“¾æŽ¥ï¼š[https://www.python.org/downloads/](https://www.python.org/downloads/)
éªŒè¯ï¼š`python3 --version`
> 

### ðŸš€API keyç”³è¯·ï¼š

âœ…Jina API: [https://jina.ai/api-dashboard/key-manager](https://jina.ai/api-dashboard/key-manager)

âœ…Gemini API: [https://aistudio.google.com/prompts/new_chat](https://aistudio.google.com/prompts/new_chat)

### ðŸš€é…ç½®

```bash
# Windows
set GEMINI_API_KEY=xxxxxx
set JINA_API_KEY=xxxxxx

git clone https://github.com/jina-ai/node-DeepResearch.git
cd node-DeepResearch
npm install

```

### ðŸš€è¿è¡Œå‘½ä»¤å¹¶æµ‹è¯•

```bash
npm run dev "1+1="
npm run dev "what is the capital of France?"
npm run dev "9.9 vs 9.11"
npm run dev "How many R letters are in the word strawberry?"
npm run dev "The hyperparameter settings for fine-tuning Llama3?"
npm run dev "SpaceXçš„åˆ›å§‹äººæ˜¯è°"
npm run dev "1+2+3+4+5+6+...+100="

# è¿è¡ŒæœåŠ¡
nohup npm run serve > output.log 2>&1 &

# é€šè¿‡æœåŠ¡APIæ¥è°ƒç”¨
curl -X POST http://localhost:3000/api/v1/query \
  -H "Content-Type: application/json" \
  -d '{
    "q": "9.9 vs 9.11",
    "budget": 1000000,
    "maxBadAttempt": 3
  }' | jq -r .requestId | xargs -I {} curl -N http://localhost:3000/api/v1/stream/{}

```

### ðŸš€ chatbotä»£ç 

```bash
# æ‰§è¡Œå‘½ä»¤å¯åŠ¨æœåŠ¡ nohup npm run serve > output.log 2>&1 &
# å®‰è£…æ‰€éœ€ä¾èµ– pip install gradio requests

# å®Œæ•´ä»£ç å¦‚ä¸‹ï¼š
import gradio as gr
import requests
import json
import time
from typing import Generator, Tuple, List, Dict

def parse_sse_data(data: str) -> dict:
    """Parse SSE data string into a dictionary."""
    if data.startswith("data: "):
        try:
            return json.loads(data[6:])  # Remove "data: " prefix
        except json.JSONDecodeError:
            return {}
    return {}

def get_final_answer(response_text: str) -> str:
    """Extract the final answer from the SSE stream."""
    lines = response_text.strip().split('\n')
    for line in reversed(lines):  # Search from the end
        parsed = parse_sse_data(line)
        if parsed.get("type") == "answer":
            return parsed.get("data", {}).get("answer", "No answer found")
    return "No answer found"

def query_api(message: str) -> str:
    """Send query to API and get response."""
    try:
        # First request to get requestId
        session = requests.Session()
        
        init_response = session.post(
            "http://localhost:3000/api/v1/query",
            json={
                "q": message,
                "budget": 1000000,
                "maxBadAttempt": 3
            },
            headers={
                "Content-Type": "application/json"
            },
            timeout=60  # Increased timeout
        )
        
        init_response.raise_for_status()
        request_id = init_response.json().get("requestId")
        
        if not request_id:
            return "Error: No request ID received"
        
        # Stream the response with increased timeout
        stream_response = session.get(
            f"http://localhost:3000/api/v1/stream/{request_id}",
            stream=True,
            timeout=120,  # Increased timeout for streaming
            headers={
                "Accept": "text/event-stream"
            }
        )
        
        stream_response.raise_for_status()
        
        full_response = ""
        for line in stream_response.iter_lines(decode_unicode=True):
            if line:
                full_response += line + '\n'
                # Check if we've received the answer
                if '"type":"answer"' in line:
                    parsed = parse_sse_data(line)
                    if parsed.get("type") == "answer":
                        answer = parsed.get("data", {}).get("answer")
                        if answer:
                            return answer
                            
        # If we haven't returned by now, try to extract answer from full response
        answer = get_final_answer(full_response)
        return answer if answer else "No answer found in response"

    except requests.exceptions.Timeout:
        return "Error: Request timed out. Please try again."
    except requests.exceptions.RequestException as e:
        return f"API Error: {str(e)}"
    except Exception as e:
        return f"Error: {str(e)}"

def format_message(role: str, content: str) -> Dict[str, str]:
    """Format message in the OpenAI-style format."""
    return {"role": role, "content": content}

def chat_response(message: str, history: List[Dict[str, str]]) -> str:
    """Handle chat interaction and return response."""
    try:
        response = query_api(message)
        return response
    except Exception as e:
        return f"Error: {str(e)}"

# Create Gradio interface
with gr.Blocks(theme=gr.themes.Soft()) as demo:
    gr.Markdown("""# AI Query Interface
    Enter your question below to get an answer from the AI system.""")
    
    chatbot = gr.Chatbot(
        label="Chat History",
        height=400,
        type="messages"
    )
    
    msg = gr.Textbox(
        label="Your Question",
        placeholder="Type your question here...",
        container=True
    )
    
    with gr.Row():
        clear = gr.Button("Clear Chat")
        submit = gr.Button("Submit", variant="primary")

    def user(user_message: str, history: List[Dict[str, str]]) -> Tuple[str, List[Dict[str, str]]]:
        if not user_message.strip():
            return "", history
        user_msg = format_message("user", user_message)
        history.append(user_msg)
        return "", history

    def bot(history: List[Dict[str, str]]) -> List[Dict[str, str]]:
        user_message = history[-1]["content"]
        bot_response = chat_response(user_message, history)
        bot_msg = format_message("assistant", bot_response)
        history.append(bot_msg)
        return history

    # Set up event handlers
    msg.submit(user, [msg, chatbot], [msg, chatbot], queue=False).then(
        bot, chatbot, chatbot
    )
    submit.click(user, [msg, chatbot], [msg, chatbot], queue=False).then(
        bot, chatbot, chatbot
    )
    clear.click(lambda: None, None, chatbot, queue=False)

if __name__ == "__main__":
    # Launch the interface with public URL enabled
    demo.launch(
        share=True,
        server_name="0.0.0.0",
        server_port=7860
    )
```