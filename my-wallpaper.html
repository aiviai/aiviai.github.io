<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI超元域 - 动态壁纸（优化版）</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1147 50%, #2d1b69 100%);
        }

        #particleCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .gradient-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(ellipse at 20% 30%, rgba(138, 43, 226, 0.15) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 70%, rgba(0, 191, 255, 0.15) 0%, transparent 50%);
            animation: gradientShift 15s ease-in-out infinite;
        }

        @keyframes gradientShift {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .text-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
        }

        #waterText {
            position: relative;
            display: inline-block;
        }

        .main-text {
            font-size: 120px;
            font-weight: 700;
            position: relative;
            display: flex;
        }

        .wave-char {
            display: inline-block;
            margin-right: 8px;
            background: linear-gradient(135deg, #00ffff, #00ff88, #00ffff, #00ff88);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientFlow 4s ease infinite, wave 2s ease-in-out infinite;
            filter: drop-shadow(0 0 40px rgba(0, 255, 255, 0.8)) 
                    drop-shadow(0 0 20px rgba(0, 255, 136, 0.6));
        }

        .wave-char:nth-child(1) { animation-delay: 0s, 0s; }
        .wave-char:nth-child(2) { animation-delay: 0s, 0.2s; }
        .wave-char:nth-child(3) { animation-delay: 0s, 0.4s; }
        .wave-char:nth-child(4) { animation-delay: 0s, 0.6s; }
        .wave-char:nth-child(5) { animation-delay: 0s, 0.8s; margin-right: 0; }

        @keyframes wave {
            0%, 100% {
                transform: translateY(0);
            }
            50% {
                transform: translateY(-20px);
            }
        }

        @keyframes gradientFlow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .glow-orbs {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .orb {
            position: absolute;
            border-radius: 50%;
            filter: blur(60px);
            animation: float 20s ease-in-out infinite;
        }

        .orb1 {
            width: 300px;
            height: 300px;
            background: radial-gradient(circle, rgba(138, 43, 226, 0.3), transparent);
            top: 10%;
            left: 15%;
            animation-delay: 0s;
        }

        .orb2 {
            width: 400px;
            height: 400px;
            background: radial-gradient(circle, rgba(0, 191, 255, 0.25), transparent);
            bottom: 15%;
            right: 20%;
            animation-delay: 5s;
        }

        .orb3 {
            width: 250px;
            height: 250px;
            background: radial-gradient(circle, rgba(123, 47, 247, 0.2), transparent);
            top: 60%;
            left: 70%;
            animation-delay: 10s;
        }

        @keyframes float {
            0%, 100% {
                transform: translate(0, 0) scale(1);
            }
            33% {
                transform: translate(50px, -50px) scale(1.1);
            }
            66% {
                transform: translate(-50px, 50px) scale(0.9);
            }
        }

        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 212, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 212, 255, 0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            opacity: 0.5;
        }

        .performance-info {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.5);
            color: #0ff;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            font-family: monospace;
            z-index: 100;
            display: none;
        }

        @media (max-width: 768px) {
            .main-text {
                font-size: 60px;
            }
            
            .wave-char {
                margin-right: 4px;
            }
        }
    </style>
</head>
<body>
    <canvas id="particleCanvas"></canvas>
    <div class="gradient-overlay"></div>
    <div class="glow-orbs">
        <div class="orb orb1"></div>
        <div class="orb orb2"></div>
        <div class="orb orb3"></div>
    </div>
    <div class="grid-overlay"></div>
    
    <div class="text-container">
        <div id="waterText">
            <div class="main-text">
                <span class="wave-char">A</span>
                <span class="wave-char">I</span>
                <span class="wave-char">超</span>
                <span class="wave-char">元</span>
                <span class="wave-char">域</span>
            </div>
        </div>
    </div>

    <div class="performance-info" id="perfInfo">
        FPS: <span id="fps">0</span><br>
        Stars: <span id="starCount">0</span><br>
        Comets: <span id="cometCount">0</span><br>
        Galaxies: <span id="galaxyCount">0</span>
    </div>

    <script>
        // 性能监控和资源管理系统
        class PerformanceManager {
            constructor() {
                this.fps = 0;
                this.frameCount = 0;
                this.lastTime = performance.now();
                this.fpsHistory = [];
                this.maxFpsHistory = 60;
            }

            update() {
                this.frameCount++;
                const currentTime = performance.now();
                const elapsed = currentTime - this.lastTime;

                if (elapsed >= 1000) {
                    this.fps = Math.round((this.frameCount * 1000) / elapsed);
                    this.fpsHistory.push(this.fps);
                    if (this.fpsHistory.length > this.maxFpsHistory) {
                        this.fpsHistory.shift();
                    }
                    this.frameCount = 0;
                    this.lastTime = currentTime;
                }
            }

            getAverageFPS() {
                if (this.fpsHistory.length === 0) return 60;
                return this.fpsHistory.reduce((a, b) => a + b) / this.fpsHistory.length;
            }

            shouldReduceQuality() {
                return this.getAverageFPS() < 30;
            }
        }

        // 资源清理管理器
        class ResourceManager {
            constructor() {
                this.timers = [];
                this.listeners = [];
                this.animationFrame = null;
            }

            addTimer(timer) {
                this.timers.push(timer);
                return timer;
            }

            addEventListener(target, event, handler) {
                target.addEventListener(event, handler);
                this.listeners.push({ target, event, handler });
            }

            setAnimationFrame(frame) {
                this.animationFrame = frame;
            }

            cleanup() {
                // 清理定时器
                this.timers.forEach(timer => clearInterval(timer));
                this.timers = [];

                // 清理事件监听器
                this.listeners.forEach(({ target, event, handler }) => {
                    target.removeEventListener(event, handler);
                });
                this.listeners = [];

                // 取消动画帧
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                }
            }
        }

        const resourceManager = new ResourceManager();
        const perfManager = new PerformanceManager();

        const canvas = document.getElementById('particleCanvas');
        const ctx = canvas.getContext('2d', { alpha: false }); // 性能优化

        function setCanvasSize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        setCanvasSize();

        // 配置对象 - 根据设备性能调整
        const config = {
            maxComets: 3,
            maxGalaxies: 2,
            starCount: window.innerWidth < 768 ? 100 : 200,
            cometSpawnInterval: 2000,
            galaxySpawnInterval: 8000
        };

        class Star {
            constructor(canvasWidth, canvasHeight) {
                this.canvasWidth = canvasWidth;
                this.canvasHeight = canvasHeight;
                this.init();
                this.twinkleSpeed = Math.random() * 0.02 + 0.01;
                this.twinklePhase = Math.random() * Math.PI * 2;
            }

            init() {
                this.x = Math.random() * this.canvasWidth;
                this.y = Math.random() * this.canvasHeight;
                this.vx = (Math.random() - 0.5) * 0.3;
                this.vy = (Math.random() - 0.5) * 0.3;
                this.baseSize = Math.random() * 2.5 + 0.5;
                this.baseOpacity = Math.random() * 0.6 + 0.4;
                this.color = this.getStarColor();
            }

            getStarColor() {
                const colors = [
                    'rgba(255, 255, 255, ',
                    'rgba(200, 230, 255, ',
                    'rgba(255, 240, 220, ',
                    'rgba(180, 220, 255, '
                ];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;

                if (this.x < 0) this.x = this.canvasWidth;
                if (this.x > this.canvasWidth) this.x = 0;
                if (this.y < 0) this.y = this.canvasHeight;
                if (this.y > this.canvasHeight) this.y = 0;

                this.twinklePhase += this.twinkleSpeed;
            }

            draw() {
                const twinkle = Math.sin(this.twinklePhase) * 0.5 + 0.5;
                const currentSize = this.baseSize * (0.7 + twinkle * 0.6);
                const currentOpacity = this.baseOpacity * (0.5 + twinkle * 0.5);

                ctx.beginPath();
                ctx.arc(this.x, this.y, currentSize, 0, Math.PI * 2);
                ctx.fillStyle = this.color + currentOpacity + ')';
                ctx.fill();

                if (currentSize > 1.5) {
                    const gradient = ctx.createRadialGradient(
                        this.x, this.y, 0,
                        this.x, this.y, currentSize * 3
                    );
                    gradient.addColorStop(0, this.color + (currentOpacity * 0.3) + ')');
                    gradient.addColorStop(1, this.color + '0)');
                    
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, currentSize * 3, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                }

                if (this.baseSize > 2 && twinkle > 0.7) {
                    ctx.strokeStyle = this.color + (currentOpacity * 0.4) + ')';
                    ctx.lineWidth = 0.5;
                    const rayLength = currentSize * 4;
                    
                    ctx.beginPath();
                    ctx.moveTo(this.x - rayLength, this.y);
                    ctx.lineTo(this.x + rayLength, this.y);
                    ctx.moveTo(this.x, this.y - rayLength);
                    ctx.lineTo(this.x, this.y + rayLength);
                    ctx.stroke();
                }
            }
        }

        class Comet {
            constructor(canvasWidth, canvasHeight) {
                this.canvasWidth = canvasWidth;
                this.canvasHeight = canvasHeight;
                this.reset();
            }

            reset() {
                const side = Math.floor(Math.random() * 4);
                const offset = 100;
                
                switch(side) {
                    case 0:
                        this.x = Math.random() * this.canvasWidth;
                        this.y = -offset;
                        this.vx = (Math.random() - 0.5) * 8;
                        this.vy = Math.random() * 6 + 4;
                        break;
                    case 1:
                        this.x = this.canvasWidth + offset;
                        this.y = Math.random() * this.canvasHeight;
                        this.vx = -(Math.random() * 6 + 4);
                        this.vy = (Math.random() - 0.5) * 8;
                        break;
                    case 2:
                        this.x = -offset;
                        this.y = Math.random() * this.canvasHeight;
                        this.vx = Math.random() * 6 + 4;
                        this.vy = (Math.random() - 0.5) * 8;
                        break;
                    case 3:
                        this.x = Math.random() * this.canvasWidth;
                        this.y = -offset;
                        this.vx = (Math.random() - 0.5) * 12;
                        this.vy = Math.random() * 8 + 6;
                        break;
                }

                this.size = Math.random() * 3 + 2;
                this.life = 1;
                this.fadeSpeed = Math.random() * 0.005 + 0.003;
                
                const colors = [
                    { r: 0, g: 255, b: 255 },
                    { r: 100, g: 200, b: 255 },
                    { r: 200, g: 100, b: 255 },
                    { r: 255, g: 255, b: 255 }
                ];
                this.color = colors[Math.floor(Math.random() * colors.length)];
                
                this.trail = [];
                this.maxTrailLength = 30;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= this.fadeSpeed;

                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > this.maxTrailLength) {
                    this.trail.shift();
                }

                if (this.x < -200 || this.x > this.canvasWidth + 200 ||
                    this.y < -200 || this.y > this.canvasHeight + 200 ||
                    this.life <= 0) {
                    return false;
                }
                return true;
            }

            draw() {
                const opacity = this.life;

                if (this.trail.length > 1) {
                    for (let i = 0; i < this.trail.length - 1; i++) {
                        const progress = i / this.trail.length;
                        const trailOpacity = opacity * progress * 0.6;
                        const trailSize = this.size * progress * 0.8;

                        const gradient = ctx.createRadialGradient(
                            this.trail[i].x, this.trail[i].y, 0,
                            this.trail[i].x, this.trail[i].y, trailSize * 4
                        );
                        gradient.addColorStop(0, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${trailOpacity})`);
                        gradient.addColorStop(0.5, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${trailOpacity * 0.5})`);
                        gradient.addColorStop(1, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 0)`);

                        ctx.beginPath();
                        ctx.arc(this.trail[i].x, this.trail[i].y, trailSize * 4, 0, Math.PI * 2);
                        ctx.fillStyle = gradient;
                        ctx.fill();
                    }

                    ctx.beginPath();
                    ctx.moveTo(this.trail[0].x, this.trail[0].y);
                    for (let i = 1; i < this.trail.length; i++) {
                        ctx.lineTo(this.trail[i].x, this.trail[i].y);
                    }
                    ctx.strokeStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${opacity * 0.3})`;
                    ctx.lineWidth = this.size * 0.5;
                    ctx.stroke();
                }

                const coreGradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, this.size * 8
                );
                coreGradient.addColorStop(0, `rgba(255, 255, 255, ${opacity})`);
                coreGradient.addColorStop(0.2, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${opacity * 0.8})`);
                coreGradient.addColorStop(0.5, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${opacity * 0.4})`);
                coreGradient.addColorStop(1, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 0)`);

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 8, 0, Math.PI * 2);
                ctx.fillStyle = coreGradient;
                ctx.fill();

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                ctx.fill();

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 2, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${opacity * 0.5})`;
                ctx.fill();
            }
        }

        class Galaxy {
            constructor(canvasWidth, canvasHeight) {
                this.canvasWidth = canvasWidth;
                this.canvasHeight = canvasHeight;
                this.reset();
            }

            reset() {
                const side = Math.floor(Math.random() * 4);
                const offset = 200;
                
                switch(side) {
                    case 0:
                        this.x = Math.random() * this.canvasWidth;
                        this.y = -offset;
                        this.vx = (Math.random() - 0.5) * 2;
                        this.vy = Math.random() * 1 + 0.5;
                        break;
                    case 1:
                        this.x = this.canvasWidth + offset;
                        this.y = Math.random() * this.canvasHeight;
                        this.vx = -(Math.random() * 1 + 0.5);
                        this.vy = (Math.random() - 0.5) * 2;
                        break;
                    case 2:
                        this.x = -offset;
                        this.y = Math.random() * this.canvasHeight;
                        this.vx = Math.random() * 1 + 0.5;
                        this.vy = (Math.random() - 0.5) * 2;
                        break;
                    case 3:
                        this.x = Math.random() * this.canvasWidth;
                        this.y = this.canvasHeight + offset;
                        this.vx = (Math.random() - 0.5) * 2;
                        this.vy = -(Math.random() * 1 + 0.5);
                        break;
                }

                this.size = Math.random() * 60 + 80;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.01;
                this.life = 1;
                this.fadeSpeed = 0.001;
                this.opacity = 0;
                this.fadeInSpeed = 0.02;
                this.fadeInComplete = false;
                
                this.stars = [];
                this.generateSpiralStars();
            }

            generateSpiralStars() {
                const armCount = 2;
                const starsPerArm = 80;
                
                for (let arm = 0; arm < armCount; arm++) {
                    for (let i = 0; i < starsPerArm; i++) {
                        const progress = i / starsPerArm;
                        const angle = arm * (Math.PI * 2 / armCount) + progress * Math.PI * 4;
                        const distance = progress * this.size;
                        const randomOffset = (Math.random() - 0.5) * 15;
                        
                        this.stars.push({
                            angle: angle,
                            distance: distance + randomOffset,
                            size: Math.random() * 1.5 + 0.5,
                            brightness: Math.random() * 0.8 + 0.2,
                            color: this.getStarColor(progress)
                        });
                    }
                }
                
                for (let i = 0; i < 50; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * this.size * 0.2;
                    this.stars.push({
                        angle: angle,
                        distance: distance,
                        size: Math.random() * 2 + 1,
                        brightness: Math.random() * 0.5 + 0.5,
                        color: { r: 255, g: 240, b: 200 }
                    });
                }
            }

            getStarColor(progress) {
                if (progress < 0.3) {
                    return { r: 255, g: 240, b: 220 };
                } else if (progress < 0.6) {
                    return { r: 180, g: 220, b: 255 };
                } else {
                    return Math.random() > 0.5 
                        ? { r: 150, g: 200, b: 255 }
                        : { r: 255, g: 180, b: 220 };
                }
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.rotation += this.rotationSpeed;
                
                if (!this.fadeInComplete) {
                    this.opacity += this.fadeInSpeed;
                    if (this.opacity >= 1) {
                        this.opacity = 1;
                        this.fadeInComplete = true;
                    }
                } else {
                    this.life -= this.fadeSpeed;
                }

                if (this.x < -300 || this.x > this.canvasWidth + 300 ||
                    this.y < -300 || this.y > this.canvasHeight + 300 ||
                    this.life <= 0) {
                    return false;
                }
                return true;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.globalAlpha = this.opacity * this.life;

                const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size * 0.3);
                coreGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                coreGradient.addColorStop(0.3, 'rgba(255, 240, 200, 0.6)');
                coreGradient.addColorStop(0.6, 'rgba(255, 220, 150, 0.3)');
                coreGradient.addColorStop(1, 'rgba(255, 200, 100, 0)');
                
                ctx.beginPath();
                ctx.arc(0, 0, this.size * 0.3, 0, Math.PI * 2);
                ctx.fillStyle = coreGradient;
                ctx.fill();

                ctx.save();
                ctx.scale(1, 0.4);
                const diskGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size);
                diskGradient.addColorStop(0, 'rgba(100, 120, 150, 0.3)');
                diskGradient.addColorStop(0.5, 'rgba(80, 100, 130, 0.15)');
                diskGradient.addColorStop(1, 'rgba(60, 80, 110, 0)');
                
                ctx.beginPath();
                ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                ctx.fillStyle = diskGradient;
                ctx.fill();
                ctx.restore();

                this.stars.forEach(star => {
                    const x = Math.cos(star.angle) * star.distance;
                    const y = Math.sin(star.angle) * star.distance * 0.4;

                    const starGradient = ctx.createRadialGradient(x, y, 0, x, y, star.size * 3);
                    starGradient.addColorStop(0, `rgba(${star.color.r}, ${star.color.g}, ${star.color.b}, ${star.brightness})`);
                    starGradient.addColorStop(0.5, `rgba(${star.color.r}, ${star.color.g}, ${star.color.b}, ${star.brightness * 0.3})`);
                    starGradient.addColorStop(1, `rgba(${star.color.r}, ${star.color.g}, ${star.color.b}, 0)`);
                    
                    ctx.beginPath();
                    ctx.arc(x, y, star.size * 3, 0, Math.PI * 2);
                    ctx.fillStyle = starGradient;
                    ctx.fill();

                    ctx.beginPath();
                    ctx.arc(x, y, star.size, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${star.color.r}, ${star.color.g}, ${star.color.b}, ${star.brightness})`;
                    ctx.fill();
                });

                ctx.save();
                ctx.scale(1, 0.4);
                const outerGlow = ctx.createRadialGradient(0, 0, this.size * 0.5, 0, 0, this.size * 1.2);
                outerGlow.addColorStop(0, 'rgba(150, 180, 255, 0)');
                outerGlow.addColorStop(0.7, 'rgba(150, 180, 255, 0.1)');
                outerGlow.addColorStop(1, 'rgba(150, 180, 255, 0)');
                
                ctx.beginPath();
                ctx.arc(0, 0, this.size * 1.2, 0, Math.PI * 2);
                ctx.fillStyle = outerGlow;
                ctx.fill();
                ctx.restore();

                ctx.restore();
            }
        }

        const stars = [];
        const comets = [];
        const galaxies = [];

        for (let i = 0; i < config.starCount; i++) {
            stars.push(new Star(canvas.width, canvas.height));
        }

        function spawnComet() {
            if (comets.length < config.maxComets && Math.random() < 0.3) {
                comets.push(new Comet(canvas.width, canvas.height));
            }
        }

        function spawnGalaxy() {
            if (galaxies.length < config.maxGalaxies && Math.random() < 0.4) {
                galaxies.push(new Galaxy(canvas.width, canvas.height));
            }
        }

        const cometTimer = setInterval(spawnComet, config.cometSpawnInterval);
        const galaxyTimer = setInterval(spawnGalaxy, config.galaxySpawnInterval);
        
        resourceManager.addTimer(cometTimer);
        resourceManager.addTimer(galaxyTimer);

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        stars.forEach(star => star.draw());

        function animate() {
            perfManager.update();
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            stars.forEach(star => {
                star.update();
                star.draw();
            });

            for (let i = galaxies.length - 1; i >= 0; i--) {
                const alive = galaxies[i].update();
                if (alive) {
                    galaxies[i].draw();
                } else {
                    galaxies.splice(i, 1);
                }
            }

            for (let i = comets.length - 1; i >= 0; i--) {
                const alive = comets[i].update();
                if (alive) {
                    comets[i].draw();
                } else {
                    comets.splice(i, 1);
                }
            }

            // 更新性能信息（可选，按F12显示）
            if (document.getElementById('perfInfo').style.display === 'block') {
                document.getElementById('fps').textContent = perfManager.fps;
                document.getElementById('starCount').textContent = stars.length;
                document.getElementById('cometCount').textContent = comets.length;
                document.getElementById('galaxyCount').textContent = galaxies.length;
            }

            const frame = requestAnimationFrame(animate);
            resourceManager.setAnimationFrame(frame);
        }

        animate();

        const resizeHandler = () => {
            setCanvasSize();
            stars.forEach(star => {
                star.canvasWidth = canvas.width;
                star.canvasHeight = canvas.height;
            });
        };
        resourceManager.addEventListener(window, 'resize', resizeHandler);

        const mouseMoveHandler = (e) => {
            const textElement = document.querySelector('#waterText');
            const rect = textElement.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            const deltaX = (e.clientX - centerX) * 0.01;
            const deltaY = (e.clientY - centerY) * 0.01;
            
            textElement.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
        };
        resourceManager.addEventListener(document, 'mousemove', mouseMoveHandler);

        // 键盘快捷键：按F12显示性能信息
        resourceManager.addEventListener(document, 'keydown', (e) => {
            if (e.key === 'F12') {
                e.preventDefault();
                const perfInfo = document.getElementById('perfInfo');
                perfInfo.style.display = perfInfo.style.display === 'none' ? 'block' : 'none';
            }
        });

        // 页面卸载时清理资源
        resourceManager.addEventListener(window, 'beforeunload', () => {
            resourceManager.cleanup();
        });

        // 页面不可见时降低性能消耗
        resourceManager.addEventListener(document, 'visibilitychange', () => {
            if (document.hidden) {
                // 页面隐藏时可以选择暂停动画
                // resourceManager.cleanup();
            }
        });
    </script>
</body>
</html>