<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI超元域 - 宇宙动态壁纸</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1147 50%, #2d1b69 100%);
        }

        /* 星云层 - 纯CSS，GPU加速 */
        .nebula-layer {
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            opacity: 0.4;
            mix-blend-mode: screen;
            animation: nebulaFloat 120s ease-in-out infinite;
            pointer-events: none;
        }

        .nebula1 {
            background: radial-gradient(ellipse at 30% 40%, 
                rgba(138, 43, 226, 0.3) 0%, 
                rgba(75, 0, 130, 0.2) 20%,
                transparent 50%);
            animation-delay: 0s;
        }

        .nebula2 {
            background: radial-gradient(ellipse at 70% 60%, 
                rgba(0, 191, 255, 0.25) 0%, 
                rgba(30, 144, 255, 0.15) 25%,
                transparent 55%);
            animation-delay: -40s;
        }

        .nebula3 {
            background: radial-gradient(ellipse at 50% 20%, 
                rgba(255, 20, 147, 0.2) 0%, 
                rgba(138, 43, 226, 0.1) 30%,
                transparent 60%);
            animation-delay: -80s;
        }

        @keyframes nebulaFloat {
            0%, 100% {
                transform: translate(0, 0) rotate(0deg) scale(1);
            }
            33% {
                transform: translate(5%, 8%) rotate(3deg) scale(1.05);
            }
            66% {
                transform: translate(-3%, -5%) rotate(-2deg) scale(0.95);
            }
        }

        /* 远景星云团 */
        .distant-nebula {
            position: absolute;
            border-radius: 50%;
            filter: blur(80px);
            opacity: 0;
            animation: distantPulse 30s ease-in-out infinite;
            pointer-events: none;
        }

        .distant-nebula1 {
            width: 600px;
            height: 400px;
            background: radial-gradient(ellipse, rgba(138, 43, 226, 0.15), transparent);
            top: 20%;
            left: 10%;
            animation-delay: 0s;
        }

        .distant-nebula2 {
            width: 500px;
            height: 500px;
            background: radial-gradient(circle, rgba(0, 191, 255, 0.12), transparent);
            bottom: 25%;
            right: 15%;
            animation-delay: 10s;
        }

        .distant-nebula3 {
            width: 450px;
            height: 350px;
            background: radial-gradient(ellipse, rgba(255, 105, 180, 0.1), transparent);
            top: 55%;
            left: 60%;
            animation-delay: 20s;
        }

        @keyframes distantPulse {
            0%, 100% {
                opacity: 0;
                transform: scale(0.8);
            }
            50% {
                opacity: 0.6;
                transform: scale(1.2);
            }
        }

        #particleCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .gradient-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(ellipse at 20% 30%, rgba(138, 43, 226, 0.15) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 70%, rgba(0, 191, 255, 0.15) 0%, transparent 50%);
            animation: gradientShift 15s ease-in-out infinite;
        }

        @keyframes gradientShift {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .text-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            perspective: 1000px;
        }

        #waterText {
            position: relative;
            display: inline-block;
            transform-style: preserve-3d;
        }

        .main-text {
            font-size: 120px;
            font-weight: 700;
            position: relative;
            display: flex;
        }

        .wave-char {
            display: inline-block;
            margin-right: 8px;
            background: linear-gradient(135deg, #00ffff, #00ff88, #00ffff, #00ff88);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientFlow 4s ease infinite, waterRipple 3s ease-in-out infinite;
            filter: drop-shadow(0 0 40px rgba(0, 255, 255, 0.8)) 
                    drop-shadow(0 0 20px rgba(0, 255, 136, 0.6));
            transform-origin: center bottom;
        }

        .wave-char:nth-child(1) { animation-delay: 0s, 0s; }
        .wave-char:nth-child(2) { animation-delay: 0s, 0.15s; }
        .wave-char:nth-child(3) { animation-delay: 0s, 0.3s; }
        .wave-char:nth-child(4) { animation-delay: 0s, 0.45s; }
        .wave-char:nth-child(5) { animation-delay: 0s, 0.6s; margin-right: 0; }

        @keyframes waterRipple {
            0%, 100% {
                transform: scaleY(1) translateY(0);
            }
            25% {
                transform: scaleY(1.05) translateY(-3px);
            }
            50% {
                transform: scaleY(0.98) translateY(2px);
            }
            75% {
                transform: scaleY(1.02) translateY(-1px);
            }
        }

        @keyframes gradientFlow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .water-reflection {
            position: absolute;
            top: 100%;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            opacity: 0.3;
            mask-image: linear-gradient(to bottom, rgba(0,0,0,0.6) 0%, transparent 100%);
            -webkit-mask-image: linear-gradient(to bottom, rgba(0,0,0,0.6) 0%, transparent 100%);
        }

        .reflection-text {
            font-size: 120px;
            font-weight: 700;
            display: flex;
            transform: scaleY(-1);
            filter: blur(2px);
        }

        .reflection-char {
            display: inline-block;
            margin-right: 8px;
            background: linear-gradient(135deg, #00ffff, #00ff88, #00ffff, #00ff88);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientFlow 4s ease infinite, reflectionWave 2.5s ease-in-out infinite;
        }

        .reflection-char:nth-child(1) { animation-delay: 0s, 0.1s; }
        .reflection-char:nth-child(2) { animation-delay: 0s, 0.25s; }
        .reflection-char:nth-child(3) { animation-delay: 0s, 0.4s; }
        .reflection-char:nth-child(4) { animation-delay: 0s, 0.55s; }
        .reflection-char:nth-child(5) { animation-delay: 0s, 0.7s; margin-right: 0; }

        @keyframes reflectionWave {
            0%, 100% {
                transform: translateY(0) scaleX(1);
            }
            33% {
                transform: translateY(2px) scaleX(1.02);
            }
            66% {
                transform: translateY(-1px) scaleX(0.99);
            }
        }

        .glow-orbs {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .orb {
            position: absolute;
            border-radius: 50%;
            filter: blur(60px);
            animation: float 20s ease-in-out infinite;
        }

        .orb1 {
            width: 300px;
            height: 300px;
            background: radial-gradient(circle, rgba(138, 43, 226, 0.3), transparent);
            top: 10%;
            left: 15%;
            animation-delay: 0s;
        }

        .orb2 {
            width: 400px;
            height: 400px;
            background: radial-gradient(circle, rgba(0, 191, 255, 0.25), transparent);
            bottom: 15%;
            right: 20%;
            animation-delay: 5s;
        }

        .orb3 {
            width: 250px;
            height: 250px;
            background: radial-gradient(circle, rgba(123, 47, 247, 0.2), transparent);
            top: 60%;
            left: 70%;
            animation-delay: 10s;
        }

        @keyframes float {
            0%, 100% {
                transform: translate(0, 0) scale(1);
            }
            33% {
                transform: translate(50px, -50px) scale(1.1);
            }
            66% {
                transform: translate(-50px, 50px) scale(0.9);
            }
        }

        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 212, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 212, 255, 0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            opacity: 0.5;
        }

        .performance-info {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: #0ff;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 12px;
            font-family: monospace;
            z-index: 100;
            display: none;
            border: 1px solid rgba(0, 255, 255, 0.3);
        }

        .perf-warning {
            color: #ff0;
        }

        .perf-good {
            color: #0f0;
        }

        @media (max-width: 768px) {
            .main-text {
                font-size: 60px;
            }
            
            .reflection-text {
                font-size: 60px;
            }
            
            .wave-char, .reflection-char {
                margin-right: 4px;
            }
        }
    </style>
</head>
<body>
    <!-- 星云层 -->
    <div class="nebula-layer nebula1"></div>
    <div class="nebula-layer nebula2"></div>
    <div class="nebula-layer nebula3"></div>
    
    <!-- 远景星云 -->
    <div class="distant-nebula distant-nebula1"></div>
    <div class="distant-nebula distant-nebula2"></div>
    <div class="distant-nebula distant-nebula3"></div>

    <canvas id="particleCanvas"></canvas>
    <div class="gradient-overlay"></div>
    <div class="glow-orbs">
        <div class="orb orb1"></div>
        <div class="orb orb2"></div>
        <div class="orb orb3"></div>
    </div>
    <div class="grid-overlay"></div>
    
    <div class="text-container">
        <div id="waterText">
            <div class="main-text">
                <span class="wave-char">A</span>
                <span class="wave-char">I</span>
                <span class="wave-char">超</span>
                <span class="wave-char">元</span>
                <span class="wave-char">域</span>
            </div>
            <div class="water-reflection">
                <div class="reflection-text">
                    <span class="reflection-char">A</span>
                    <span class="reflection-char">I</span>
                    <span class="reflection-char">超</span>
                    <span class="reflection-char">元</span>
                    <span class="reflection-char">域</span>
                </div>
            </div>
        </div>
    </div>

    <div class="performance-info" id="perfInfo">
        <div>FPS: <span id="fps" class="perf-good">60</span></div>
        <div>Stars: <span id="starCount">0</span></div>
        <div>Comets: <span id="cometCount">0</span></div>
        <div>Pulsars: <span id="pulsarCount">0</span></div>
        <div>Memory: <span id="memoryUsage">N/A</span></div>
        <div style="margin-top: 5px; font-size: 10px;">按 F12 切换显示</div>
    </div>

    <script>
        class PerformanceManager {
            constructor() {
                this.fps = 0;
                this.frameCount = 0;
                this.lastTime = performance.now();
                this.fpsHistory = [];
                this.maxFpsHistory = 120;
                this.memoryCheckInterval = null;
                this.performanceMode = 'normal';
            }

            start() {
                this.memoryCheckInterval = setInterval(() => {
                    this.checkPerformance();
                }, 5000);
            }

            update() {
                this.frameCount++;
                const currentTime = performance.now();
                const elapsed = currentTime - this.lastTime;

                if (elapsed >= 1000) {
                    this.fps = Math.round((this.frameCount * 1000) / elapsed);
                    this.fpsHistory.push(this.fps);
                    if (this.fpsHistory.length > this.maxFpsHistory) {
                        this.fpsHistory.shift();
                    }
                    this.frameCount = 0;
                    this.lastTime = currentTime;
                }
            }

            getAverageFPS() {
                if (this.fpsHistory.length === 0) return 60;
                const sum = this.fpsHistory.reduce((a, b) => a + b, 0);
                return sum / this.fpsHistory.length;
            }

            checkPerformance() {
                const avgFPS = this.getAverageFPS();
                
                if (avgFPS < 40 && this.performanceMode === 'normal') {
                    this.performanceMode = 'reduced';
                    console.warn('性能降级：FPS过低');
                } else if (avgFPS > 50 && this.performanceMode === 'reduced') {
                    this.performanceMode = 'normal';
                    console.log('性能恢复');
                }

                if (performance.memory) {
                    const memoryMB = (performance.memory.usedJSHeapSize / 1048576).toFixed(2);
                    const memoryLimitMB = (performance.memory.jsHeapSizeLimit / 1048576).toFixed(2);
                    
                    if (document.getElementById('perfInfo').style.display === 'block') {
                        document.getElementById('memoryUsage').textContent = 
                            `${memoryMB} / ${memoryLimitMB} MB`;
                    }
                }
            }

            shouldReduceQuality() {
                return this.performanceMode === 'reduced';
            }

            cleanup() {
                if (this.memoryCheckInterval) {
                    clearInterval(this.memoryCheckInterval);
                }
            }
        }

        class ResourceManager {
            constructor() {
                this.timers = [];
                this.listeners = [];
                this.animationFrame = null;
            }

            addTimer(timer) {
                this.timers.push(timer);
                return timer;
            }

            addEventListener(target, event, handler) {
                target.addEventListener(event, handler);
                this.listeners.push({ target, event, handler });
            }

            setAnimationFrame(frame) {
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                }
                this.animationFrame = frame;
            }

            cleanup() {
                this.timers.forEach(timer => clearInterval(timer));
                this.timers = [];
                this.listeners.forEach(({ target, event, handler }) => {
                    target.removeEventListener(event, handler);
                });
                this.listeners = [];
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                    this.animationFrame = null;
                }
            }
        }

        const resourceManager = new ResourceManager();
        const perfManager = new PerformanceManager();

        const canvas = document.getElementById('particleCanvas');
        const ctx = canvas.getContext('2d', { 
            alpha: false,
            desynchronized: true
        });

        function setCanvasSize() {
            const newWidth = window.innerWidth;
            const newHeight = window.innerHeight;
            
            if (canvas.width !== newWidth || canvas.height !== newHeight) {
                canvas.width = newWidth;
                canvas.height = newHeight;
            }
        }
        setCanvasSize();

        const config = {
            maxComets: 2,
            starCount: 50,
            pulsarCount: 3,
            cometSpawnInterval: 3000,
            cometSpawnChance: 0.3,
            meteorShowerChance: 0.002, // 流星雨概率
            constellationLineChance: 0.6
        };

        // 星星类（含脉冲星）
        class Star {
            constructor(canvasWidth, canvasHeight, isPulsar = false) {
                this.canvasWidth = canvasWidth;
                this.canvasHeight = canvasHeight;
                this.isPulsar = isPulsar;
                this.init();
            }

            init() {
                this.x = Math.random() * this.canvasWidth;
                this.y = Math.random() * this.canvasHeight;
                this.vx = (Math.random() - 0.5) * 0.3;
                this.vy = (Math.random() - 0.5) * 0.3;
                
                if (this.isPulsar) {
                    this.baseSize = Math.random() * 2 + 2.5;
                    this.baseOpacity = 0.9;
                    this.twinkleSpeed = Math.random() * 0.15 + 0.15;
                    this.color = 'rgba(255, 100, 255, ';
                } else {
                    this.baseSize = Math.random() * 2.5 + 0.5;
                    this.baseOpacity = Math.random() * 0.6 + 0.4;
                    this.twinkleSpeed = Math.random() * 0.02 + 0.01;
                    const colors = [
                        'rgba(255, 255, 255, ',
                        'rgba(200, 230, 255, ',
                        'rgba(255, 240, 220, ',
                        'rgba(180, 220, 255, '
                    ];
                    this.color = colors[Math.floor(Math.random() * colors.length)];
                }
                
                this.twinklePhase = Math.random() * Math.PI * 2;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;

                if (this.x < 0) this.x = this.canvasWidth;
                if (this.x > this.canvasWidth) this.x = 0;
                if (this.y < 0) this.y = this.canvasHeight;
                if (this.y > this.canvasHeight) this.y = 0;

                this.twinklePhase += this.twinkleSpeed;
            }

            draw(reduceQuality = false) {
                const twinkle = Math.sin(this.twinklePhase) * 0.5 + 0.5;
                const currentSize = this.baseSize * (0.7 + twinkle * 0.6);
                const currentOpacity = this.baseOpacity * (0.5 + twinkle * 0.5);

                ctx.beginPath();
                ctx.arc(this.x, this.y, currentSize, 0, Math.PI * 2);
                ctx.fillStyle = this.color + currentOpacity + ')';
                ctx.fill();

                if (!reduceQuality && currentSize > 1.5) {
                    const gradient = ctx.createRadialGradient(
                        this.x, this.y, 0,
                        this.x, this.y, currentSize * (this.isPulsar ? 5 : 3)
                    );
                    gradient.addColorStop(0, this.color + (currentOpacity * 0.3) + ')');
                    gradient.addColorStop(1, this.color + '0)');
                    
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, currentSize * (this.isPulsar ? 5 : 3), 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                }

                if (!reduceQuality && this.baseSize > 2 && twinkle > 0.7) {
                    ctx.strokeStyle = this.color + (currentOpacity * 0.4) + ')';
                    ctx.lineWidth = 0.5;
                    const rayLength = currentSize * 4;
                    
                    ctx.beginPath();
                    ctx.moveTo(this.x - rayLength, this.y);
                    ctx.lineTo(this.x + rayLength, this.y);
                    ctx.moveTo(this.x, this.y - rayLength);
                    ctx.lineTo(this.x, this.y + rayLength);
                    ctx.stroke();
                }
            }
        }

        // 彗星/流星类
        class Comet {
            constructor(canvasWidth, canvasHeight, isMeteor = false) {
                this.canvasWidth = canvasWidth;
                this.canvasHeight = canvasHeight;
                this.isMeteor = isMeteor;
                this.reset();
            }

            reset() {
                const side = Math.floor(Math.random() * 4);
                const offset = 100;
                
                const speedMultiplier = this.isMeteor ? 2 : 1;
                
                switch(side) {
                    case 0:
                        this.x = Math.random() * this.canvasWidth;
                        this.y = -offset;
                        this.vx = (Math.random() - 0.5) * 8 * speedMultiplier;
                        this.vy = (Math.random() * 6 + 4) * speedMultiplier;
                        break;
                    case 1:
                        this.x = this.canvasWidth + offset;
                        this.y = Math.random() * this.canvasHeight;
                        this.vx = -(Math.random() * 6 + 4) * speedMultiplier;
                        this.vy = (Math.random() - 0.5) * 8 * speedMultiplier;
                        break;
                    case 2:
                        this.x = -offset;
                        this.y = Math.random() * this.canvasHeight;
                        this.vx = (Math.random() * 6 + 4) * speedMultiplier;
                        this.vy = (Math.random() - 0.5) * 8 * speedMultiplier;
                        break;
                    case 3:
                        this.x = Math.random() * this.canvasWidth;
                        this.y = -offset;
                        this.vx = (Math.random() - 0.5) * 12 * speedMultiplier;
                        this.vy = (Math.random() * 8 + 6) * speedMultiplier;
                        break;
                }

                this.size = this.isMeteor ? Math.random() * 1.5 + 1 : Math.random() * 3 + 2;
                this.life = 1;
                this.fadeSpeed = this.isMeteor ? Math.random() * 0.015 + 0.01 : Math.random() * 0.005 + 0.003;
                
                const colors = [
                    { r: 0, g: 255, b: 255 },
                    { r: 100, g: 200, b: 255 },
                    { r: 200, g: 100, b: 255 },
                    { r: 255, g: 255, b: 255 }
                ];
                this.color = colors[Math.floor(Math.random() * colors.length)];
                
                this.trail = new Array(this.isMeteor ? 15 : 30).fill(null).map(() => ({ x: this.x, y: this.y }));
                this.trailIndex = 0;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= this.fadeSpeed;

                this.trail[this.trailIndex] = { x: this.x, y: this.y };
                this.trailIndex = (this.trailIndex + 1) % this.trail.length;

                if (this.x < -200 || this.x > this.canvasWidth + 200 ||
                    this.y < -200 || this.y > this.canvasHeight + 200 ||
                    this.life <= 0) {
                    return false;
                }
                return true;
            }

            draw(reduceQuality = false) {
                const opacity = this.life;
                const trailLength = reduceQuality ? (this.isMeteor ? 8 : 15) : this.trail.length;
                
                for (let i = 0; i < trailLength; i++) {
                    const idx = (this.trailIndex - i + this.trail.length) % this.trail.length;
                    const point = this.trail[idx];
                    
                    if (!point) continue;

                    const progress = i / trailLength;
                    const trailOpacity = opacity * (1 - progress) * 0.6;
                    const trailSize = this.size * (1 - progress * 0.5);

                    if (trailSize < 0.1) continue;

                    const gradient = ctx.createRadialGradient(
                        point.x, point.y, 0,
                        point.x, point.y, trailSize * 4
                    );
                    gradient.addColorStop(0, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${trailOpacity})`);
                    gradient.addColorStop(1, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 0)`);

                    ctx.beginPath();
                    ctx.arc(point.x, point.y, trailSize * 4, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                }

                const coreGradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, this.size * 8
                );
                coreGradient.addColorStop(0, `rgba(255, 255, 255, ${opacity})`);
                coreGradient.addColorStop(0.2, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${opacity * 0.8})`);
                coreGradient.addColorStop(1, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 0)`);

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 8, 0, Math.PI * 2);
                ctx.fillStyle = coreGradient;
                ctx.fill();

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                ctx.fill();
            }

            dispose() {
                this.trail = null;
            }
        }

        const stars = [];
        const comets = [];
        const meteors = [];

        // 初始化星星（包含脉冲星）
        for (let i = 0; i < config.starCount; i++) {
            const isPulsar = i < config.pulsarCount;
            stars.push(new Star(canvas.width, canvas.height, isPulsar));
        }

        // 星座连线效果（轻量级）
        function drawConstellations(reduceQuality) {
            if (reduceQuality || Math.random() > config.constellationLineChance) return;
            
            ctx.strokeStyle = 'rgba(100, 150, 255, 0.15)';
            ctx.lineWidth = 0.5;
            
            const maxDistance = 150;
            const maxLines = 5;
            let lineCount = 0;
            
            for (let i = 0; i < stars.length && lineCount < maxLines; i++) {
                for (let j = i + 1; j < stars.length && lineCount < maxLines; j++) {
                    const dx = stars[i].x - stars[j].x;
                    const dy = stars[i].y - stars[j].y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < maxDistance && Math.random() > 0.95) {
                        ctx.beginPath();
                        ctx.moveTo(stars[i].x, stars[i].y);
                        ctx.lineTo(stars[j].x, stars[j].y);
                        ctx.stroke();
                        lineCount++;
                    }
                }
            }
        }

        function spawnComet() {
            if (comets.length < config.maxComets && Math.random() < config.cometSpawnChance) {
                comets.push(new Comet(canvas.width, canvas.height, false));
            }
        }

        // 流星雨效果
        function checkMeteorShower() {
            if (Math.random() < config.meteorShowerChance) {
                console.log('🌠 流星雨！');
                const meteorCount = Math.floor(Math.random() * 3) + 2;
                for (let i = 0; i < meteorCount; i++) {
                    setTimeout(() => {
                        meteors.push(new Comet(canvas.width, canvas.height, true));
                    }, i * 200);
                }
            }
        }

        const cometTimer = setInterval(spawnComet, config.cometSpawnInterval);
        const meteorShowerTimer = setInterval(checkMeteorShower, 10000);
        
        resourceManager.addTimer(cometTimer);
        resourceManager.addTimer(meteorShowerTimer);

        perfManager.start();

        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        stars.forEach(star => star.draw());

        let lastFrameTime = performance.now();

        function animate() {
            perfManager.update();
            
            const now = performance.now();
            const deltaTime = now - lastFrameTime;
            lastFrameTime = now;

            const skipComplexRender = deltaTime > 50;
            const reduceQuality = perfManager.shouldReduceQuality() || skipComplexRender;

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 星座连线
            drawConstellations(reduceQuality);

            // 星星
            stars.forEach(star => {
                star.update();
                star.draw(reduceQuality);
            });

            // 彗星
            for (let i = comets.length - 1; i >= 0; i--) {
                const alive = comets[i].update();
                if (alive) {
                    comets[i].draw(reduceQuality);
                } else {
                    comets[i].dispose();
                    comets.splice(i, 1);
                }
            }

            // 流星
            for (let i = meteors.length - 1; i >= 0; i--) {
                const alive = meteors[i].update();
                if (alive) {
                    meteors[i].draw(reduceQuality);
                } else {
                    meteors[i].dispose();
                    meteors.splice(i, 1);
                }
            }

            // 更新性能信息
            if (document.getElementById('perfInfo').style.display === 'block') {
                const fpsElement = document.getElementById('fps');
                fpsElement.textContent = perfManager.fps;
                
                if (perfManager.fps >= 50) {
                    fpsElement.className = 'perf-good';
                } else if (perfManager.fps >= 30) {
                    fpsElement.className = 'perf-warning';
                } else {
                    fpsElement.style.color = '#f00';
                }
                
                document.getElementById('starCount').textContent = stars.length;
                document.getElementById('cometCount').textContent = comets.length;
                document.getElementById('pulsarCount').textContent = config.pulsarCount;
            }

            const frame = requestAnimationFrame(animate);
            resourceManager.setAnimationFrame(frame);
        }

        animate();

        const resizeHandler = () => {
            setCanvasSize();
            stars.forEach(star => {
                star.canvasWidth = canvas.width;
                star.canvasHeight = canvas.height;
            });
        };
        resourceManager.addEventListener(window, 'resize', resizeHandler);

        const mouseMoveHandler = (e) => {
            const textElement = document.querySelector('#waterText');
            const rect = textElement.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            const deltaX = (e.clientX - centerX) * 0.008;
            const deltaY = (e.clientY - centerY) * 0.008;
            
            textElement.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
        };
        resourceManager.addEventListener(document, 'mousemove', mouseMoveHandler);

        resourceManager.addEventListener(document, 'keydown', (e) => {
            if (e.key === 'F12') {
                e.preventDefault();
                const perfInfo = document.getElementById('perfInfo');
                perfInfo.style.display = perfInfo.style.display === 'none' ? 'block' : 'none';
            }
        });

        resourceManager.addEventListener(window, 'beforeunload', () => {
            perfManager.cleanup();
            resourceManager.cleanup();
            
            comets.forEach(comet => comet.dispose());
            meteors.forEach(meteor => meteor.dispose());
            comets.length = 0;
            meteors.length = 0;
            stars.length = 0;
        });

        console.log('🌌 宇宙壁纸初始化完成');
        console.log('✨ 新增效果：');
        console.log('  - 多层星云（CSS GPU加速）');
        console.log('  - 脉冲星（3颗快速闪烁）');
        console.log('  - 星座连线');
        console.log('  - 流星雨（随机触发）');
        console.log('  - 远景星云团');
        console.log('📊 按 F12 显示性能监控');
    </script>
</body>
</html>