<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AIè¶…å…ƒåŸŸ - åŠ¨æ€å£çº¸</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1147 50%, #2d1b69 100%);
        }

        #particleCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .gradient-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(ellipse at 20% 30%, rgba(138, 43, 226, 0.15) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 70%, rgba(0, 191, 255, 0.15) 0%, transparent 50%);
            animation: gradientShift 15s ease-in-out infinite;
        }

        @keyframes gradientShift {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .text-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            perspective: 1000px;
        }

        #waterText {
            position: relative;
            display: inline-block;
            transform-style: preserve-3d;
        }

        .main-text {
            font-size: 120px;
            font-weight: 700;
            position: relative;
            display: flex;
        }

        .wave-char {
            display: inline-block;
            margin-right: 8px;
            background: linear-gradient(135deg, #00ffff, #00ff88, #00ffff, #00ff88);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientFlow 4s ease infinite, waterRipple 3s ease-in-out infinite;
            filter: drop-shadow(0 0 40px rgba(0, 255, 255, 0.8)) 
                    drop-shadow(0 0 20px rgba(0, 255, 136, 0.6));
            transform-origin: center bottom;
        }

        .wave-char:nth-child(1) { animation-delay: 0s, 0s; }
        .wave-char:nth-child(2) { animation-delay: 0s, 0.15s; }
        .wave-char:nth-child(3) { animation-delay: 0s, 0.3s; }
        .wave-char:nth-child(4) { animation-delay: 0s, 0.45s; }
        .wave-char:nth-child(5) { animation-delay: 0s, 0.6s; margin-right: 0; }

        /* æ°´é¢æ³¢åŠ¨æ•ˆæœ */
        @keyframes waterRipple {
            0%, 100% {
                transform: scaleY(1) translateY(0);
            }
            25% {
                transform: scaleY(1.05) translateY(-3px);
            }
            50% {
                transform: scaleY(0.98) translateY(2px);
            }
            75% {
                transform: scaleY(1.02) translateY(-1px);
            }
        }

        @keyframes gradientFlow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        /* æ°´é¢å€’å½±æ•ˆæœ */
        .water-reflection {
            position: absolute;
            top: 100%;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            opacity: 0.3;
            mask-image: linear-gradient(to bottom, rgba(0,0,0,0.6) 0%, transparent 100%);
            -webkit-mask-image: linear-gradient(to bottom, rgba(0,0,0,0.6) 0%, transparent 100%);
        }

        .reflection-text {
            font-size: 120px;
            font-weight: 700;
            display: flex;
            transform: scaleY(-1);
            filter: blur(2px);
        }

        .reflection-char {
            display: inline-block;
            margin-right: 8px;
            background: linear-gradient(135deg, #00ffff, #00ff88, #00ffff, #00ff88);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientFlow 4s ease infinite, reflectionWave 2.5s ease-in-out infinite;
        }

        .reflection-char:nth-child(1) { animation-delay: 0s, 0.1s; }
        .reflection-char:nth-child(2) { animation-delay: 0s, 0.25s; }
        .reflection-char:nth-child(3) { animation-delay: 0s, 0.4s; }
        .reflection-char:nth-child(4) { animation-delay: 0s, 0.55s; }
        .reflection-char:nth-child(5) { animation-delay: 0s, 0.7s; margin-right: 0; }

        @keyframes reflectionWave {
            0%, 100% {
                transform: translateY(0) scaleX(1);
            }
            33% {
                transform: translateY(2px) scaleX(1.02);
            }
            66% {
                transform: translateY(-1px) scaleX(0.99);
            }
        }

        .glow-orbs {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .orb {
            position: absolute;
            border-radius: 50%;
            filter: blur(60px);
            animation: float 20s ease-in-out infinite;
        }

        .orb1 {
            width: 300px;
            height: 300px;
            background: radial-gradient(circle, rgba(138, 43, 226, 0.3), transparent);
            top: 10%;
            left: 15%;
            animation-delay: 0s;
        }

        .orb2 {
            width: 400px;
            height: 400px;
            background: radial-gradient(circle, rgba(0, 191, 255, 0.25), transparent);
            bottom: 15%;
            right: 20%;
            animation-delay: 5s;
        }

        .orb3 {
            width: 250px;
            height: 250px;
            background: radial-gradient(circle, rgba(123, 47, 247, 0.2), transparent);
            top: 60%;
            left: 70%;
            animation-delay: 10s;
        }

        @keyframes float {
            0%, 100% {
                transform: translate(0, 0) scale(1);
            }
            33% {
                transform: translate(50px, -50px) scale(1.1);
            }
            66% {
                transform: translate(-50px, 50px) scale(0.9);
            }
        }

        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 212, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 212, 255, 0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            opacity: 0.5;
        }

        .performance-info {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: #0ff;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 12px;
            font-family: monospace;
            z-index: 100;
            display: none;
            border: 1px solid rgba(0, 255, 255, 0.3);
        }

        .perf-warning {
            color: #ff0;
        }

        .perf-good {
            color: #0f0;
        }

        @media (max-width: 768px) {
            .main-text {
                font-size: 60px;
            }
            
            .reflection-text {
                font-size: 60px;
            }
            
            .wave-char, .reflection-char {
                margin-right: 4px;
            }
        }
    </style>
</head>
<body>
    <canvas id="particleCanvas"></canvas>
    <div class="gradient-overlay"></div>
    <div class="glow-orbs">
        <div class="orb orb1"></div>
        <div class="orb orb2"></div>
        <div class="orb orb3"></div>
    </div>
    <div class="grid-overlay"></div>
    
    <div class="text-container">
        <div id="waterText">
            <div class="main-text">
                <span class="wave-char">A</span>
                <span class="wave-char">I</span>
                <span class="wave-char">è¶…</span>
                <span class="wave-char">å…ƒ</span>
                <span class="wave-char">åŸŸ</span>
            </div>
            <div class="water-reflection">
                <div class="reflection-text">
                    <span class="reflection-char">A</span>
                    <span class="reflection-char">I</span>
                    <span class="reflection-char">è¶…</span>
                    <span class="reflection-char">å…ƒ</span>
                    <span class="reflection-char">åŸŸ</span>
                </div>
            </div>
        </div>
    </div>

    <div class="performance-info" id="perfInfo">
        <div>FPS: <span id="fps" class="perf-good">60</span></div>
        <div>Stars: <span id="starCount">0</span></div>
        <div>Comets: <span id="cometCount">0</span></div>
        <div>Memory: <span id="memoryUsage">N/A</span></div>
        <div style="margin-top: 5px; font-size: 10px;">æŒ‰ F12 åˆ‡æ¢æ˜¾ç¤º</div>
    </div>

    <script>
        // æ€§èƒ½ç›‘æ§å’Œèµ„æºç®¡ç†ç³»ç»Ÿï¼ˆå¢å¼ºç‰ˆï¼‰
        class PerformanceManager {
            constructor() {
                this.fps = 0;
                this.frameCount = 0;
                this.lastTime = performance.now();
                this.fpsHistory = [];
                this.maxFpsHistory = 120; // 2ç§’çš„å†å²è®°å½•ï¼ˆ60fpsï¼‰
                this.memoryCheckInterval = null;
                this.performanceMode = 'normal'; // normal, reduced
            }

            start() {
                // æ¯5ç§’æ£€æŸ¥ä¸€æ¬¡å†…å­˜
                this.memoryCheckInterval = setInterval(() => {
                    this.checkPerformance();
                }, 5000);
            }

            update() {
                this.frameCount++;
                const currentTime = performance.now();
                const elapsed = currentTime - this.lastTime;

                if (elapsed >= 1000) {
                    this.fps = Math.round((this.frameCount * 1000) / elapsed);
                    this.fpsHistory.push(this.fps);
                    if (this.fpsHistory.length > this.maxFpsHistory) {
                        this.fpsHistory.shift();
                    }
                    this.frameCount = 0;
                    this.lastTime = currentTime;
                }
            }

            getAverageFPS() {
                if (this.fpsHistory.length === 0) return 60;
                const sum = this.fpsHistory.reduce((a, b) => a + b, 0);
                return sum / this.fpsHistory.length;
            }

            checkPerformance() {
                const avgFPS = this.getAverageFPS();
                
                // å¦‚æœå¹³å‡FPSä½äº40ï¼Œåˆ‡æ¢åˆ°é™çº§æ¨¡å¼
                if (avgFPS < 40 && this.performanceMode === 'normal') {
                    this.performanceMode = 'reduced';
                    console.warn('æ€§èƒ½é™çº§ï¼šFPSè¿‡ä½ï¼Œå‡å°‘ç²’å­æ•ˆæœ');
                } else if (avgFPS > 50 && this.performanceMode === 'reduced') {
                    this.performanceMode = 'normal';
                    console.log('æ€§èƒ½æ¢å¤ï¼šFPSæ­£å¸¸');
                }

                // æ£€æŸ¥å†…å­˜ä½¿ç”¨ï¼ˆå¦‚æœæµè§ˆå™¨æ”¯æŒï¼‰
                if (performance.memory) {
                    const memoryMB = (performance.memory.usedJSHeapSize / 1048576).toFixed(2);
                    const memoryLimitMB = (performance.memory.jsHeapSizeLimit / 1048576).toFixed(2);
                    
                    if (document.getElementById('perfInfo').style.display === 'block') {
                        document.getElementById('memoryUsage').textContent = 
                            `${memoryMB} / ${memoryLimitMB} MB`;
                    }

                    // å¦‚æœå†…å­˜ä½¿ç”¨è¶…è¿‡é™åˆ¶çš„80%ï¼Œè­¦å‘Š
                    if (performance.memory.usedJSHeapSize > performance.memory.jsHeapSizeLimit * 0.8) {
                        console.warn('å†…å­˜ä½¿ç”¨è¿‡é«˜ï¼Œå¯èƒ½éœ€è¦ä¼˜åŒ–');
                    }
                }
            }

            shouldReduceQuality() {
                return this.performanceMode === 'reduced';
            }

            cleanup() {
                if (this.memoryCheckInterval) {
                    clearInterval(this.memoryCheckInterval);
                }
            }
        }

        // èµ„æºæ¸…ç†ç®¡ç†å™¨
        class ResourceManager {
            constructor() {
                this.timers = [];
                this.listeners = [];
                this.animationFrame = null;
            }

            addTimer(timer) {
                this.timers.push(timer);
                return timer;
            }

            addEventListener(target, event, handler) {
                target.addEventListener(event, handler);
                this.listeners.push({ target, event, handler });
            }

            setAnimationFrame(frame) {
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                }
                this.animationFrame = frame;
            }

            cleanup() {
                console.log('æ¸…ç†èµ„æº...');
                
                // æ¸…ç†å®šæ—¶å™¨
                this.timers.forEach(timer => clearInterval(timer));
                this.timers = [];

                // æ¸…ç†äº‹ä»¶ç›‘å¬å™¨
                this.listeners.forEach(({ target, event, handler }) => {
                    target.removeEventListener(event, handler);
                });
                this.listeners = [];

                // å–æ¶ˆåŠ¨ç”»å¸§
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                    this.animationFrame = null;
                }

                console.log('èµ„æºæ¸…ç†å®Œæˆ');
            }
        }

        // æ¸å˜ç¼“å­˜ç³»ç»Ÿï¼ˆå‡å°‘é‡å¤åˆ›å»ºï¼‰
        class GradientCache {
            constructor(ctx) {
                this.ctx = ctx;
                this.cache = new Map();
            }

            getOrCreate(key, creator) {
                if (!this.cache.has(key)) {
                    this.cache.set(key, creator());
                }
                return this.cache.get(key);
            }

            clear() {
                this.cache.clear();
            }
        }

        const resourceManager = new ResourceManager();
        const perfManager = new PerformanceManager();

        const canvas = document.getElementById('particleCanvas');
        const ctx = canvas.getContext('2d', { 
            alpha: false,
            desynchronized: true // æå‡æ€§èƒ½
        });

        const gradientCache = new GradientCache(ctx);

        function setCanvasSize() {
            const newWidth = window.innerWidth;
            const newHeight = window.innerHeight;
            
            if (canvas.width !== newWidth || canvas.height !== newHeight) {
                canvas.width = newWidth;
                canvas.height = newHeight;
                // æ¸…ç©ºæ¸å˜ç¼“å­˜
                gradientCache.clear();
            }
        }
        setCanvasSize();

        // é…ç½®å¯¹è±¡
        const config = {
            maxComets: 2,
            starCount: 50,
            cometSpawnInterval: 3000,
            cometSpawnChance: 0.3
        };

        class Star {
            constructor(canvasWidth, canvasHeight) {
                this.canvasWidth = canvasWidth;
                this.canvasHeight = canvasHeight;
                this.init();
            }

            init() {
                this.x = Math.random() * this.canvasWidth;
                this.y = Math.random() * this.canvasHeight;
                this.vx = (Math.random() - 0.5) * 0.3;
                this.vy = (Math.random() - 0.5) * 0.3;
                this.baseSize = Math.random() * 2.5 + 0.5;
                this.baseOpacity = Math.random() * 0.6 + 0.4;
                this.twinkleSpeed = Math.random() * 0.02 + 0.01;
                this.twinklePhase = Math.random() * Math.PI * 2;
                
                const colors = [
                    'rgba(255, 255, 255, ',
                    'rgba(200, 230, 255, ',
                    'rgba(255, 240, 220, ',
                    'rgba(180, 220, 255, '
                ];
                this.color = colors[Math.floor(Math.random() * colors.length)];
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;

                // è¾¹ç•Œå¾ªç¯
                if (this.x < 0) this.x = this.canvasWidth;
                if (this.x > this.canvasWidth) this.x = 0;
                if (this.y < 0) this.y = this.canvasHeight;
                if (this.y > this.canvasHeight) this.y = 0;

                this.twinklePhase += this.twinkleSpeed;
            }

            draw(reduceQuality = false) {
                const twinkle = Math.sin(this.twinklePhase) * 0.5 + 0.5;
                const currentSize = this.baseSize * (0.7 + twinkle * 0.6);
                const currentOpacity = this.baseOpacity * (0.5 + twinkle * 0.5);

                // ç»˜åˆ¶æ˜Ÿæ˜Ÿä¸»ä½“
                ctx.beginPath();
                ctx.arc(this.x, this.y, currentSize, 0, Math.PI * 2);
                ctx.fillStyle = this.color + currentOpacity + ')';
                ctx.fill();

                // å¦‚æœæ€§èƒ½è‰¯å¥½ï¼Œæ·»åŠ å…‰æ™•
                if (!reduceQuality && currentSize > 1.5) {
                    const gradient = ctx.createRadialGradient(
                        this.x, this.y, 0,
                        this.x, this.y, currentSize * 3
                    );
                    gradient.addColorStop(0, this.color + (currentOpacity * 0.3) + ')');
                    gradient.addColorStop(1, this.color + '0)');
                    
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, currentSize * 3, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                }

                // å¤§æ˜Ÿæ˜Ÿæ·»åŠ åå­—å…‰èŠ’
                if (!reduceQuality && this.baseSize > 2 && twinkle > 0.7) {
                    ctx.strokeStyle = this.color + (currentOpacity * 0.4) + ')';
                    ctx.lineWidth = 0.5;
                    const rayLength = currentSize * 4;
                    
                    ctx.beginPath();
                    ctx.moveTo(this.x - rayLength, this.y);
                    ctx.lineTo(this.x + rayLength, this.y);
                    ctx.moveTo(this.x, this.y - rayLength);
                    ctx.lineTo(this.x, this.y + rayLength);
                    ctx.stroke();
                }
            }
        }

        class Comet {
            constructor(canvasWidth, canvasHeight) {
                this.canvasWidth = canvasWidth;
                this.canvasHeight = canvasHeight;
                this.reset();
            }

            reset() {
                const side = Math.floor(Math.random() * 4);
                const offset = 100;
                
                switch(side) {
                    case 0:
                        this.x = Math.random() * this.canvasWidth;
                        this.y = -offset;
                        this.vx = (Math.random() - 0.5) * 8;
                        this.vy = Math.random() * 6 + 4;
                        break;
                    case 1:
                        this.x = this.canvasWidth + offset;
                        this.y = Math.random() * this.canvasHeight;
                        this.vx = -(Math.random() * 6 + 4);
                        this.vy = (Math.random() - 0.5) * 8;
                        break;
                    case 2:
                        this.x = -offset;
                        this.y = Math.random() * this.canvasHeight;
                        this.vx = Math.random() * 6 + 4;
                        this.vy = (Math.random() - 0.5) * 8;
                        break;
                    case 3:
                        this.x = Math.random() * this.canvasWidth;
                        this.y = -offset;
                        this.vx = (Math.random() - 0.5) * 12;
                        this.vy = Math.random() * 8 + 6;
                        break;
                }

                this.size = Math.random() * 3 + 2;
                this.life = 1;
                this.fadeSpeed = Math.random() * 0.005 + 0.003;
                
                const colors = [
                    { r: 0, g: 255, b: 255 },
                    { r: 100, g: 200, b: 255 },
                    { r: 200, g: 100, b: 255 },
                    { r: 255, g: 255, b: 255 }
                ];
                this.color = colors[Math.floor(Math.random() * colors.length)];
                
                // ä¼˜åŒ–ï¼šä½¿ç”¨å›ºå®šå¤§å°çš„æ•°ç»„ï¼Œå‡å°‘å†…å­˜åˆ†é…
                this.trail = new Array(30).fill(null).map(() => ({ x: this.x, y: this.y }));
                this.trailIndex = 0;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= this.fadeSpeed;

                // ä½¿ç”¨å¾ªç¯æ•°ç»„è®°å½•è½¨è¿¹ï¼Œé¿å… shift/push
                this.trail[this.trailIndex] = { x: this.x, y: this.y };
                this.trailIndex = (this.trailIndex + 1) % this.trail.length;

                // æ£€æŸ¥æ˜¯å¦ç¦»å¼€å±å¹•
                if (this.x < -200 || this.x > this.canvasWidth + 200 ||
                    this.y < -200 || this.y > this.canvasHeight + 200 ||
                    this.life <= 0) {
                    return false;
                }
                return true;
            }

            draw(reduceQuality = false) {
                const opacity = this.life;

                // ç»˜åˆ¶å½—æ˜Ÿå°¾å·´
                const trailLength = reduceQuality ? 15 : 30;
                for (let i = 0; i < trailLength; i++) {
                    const idx = (this.trailIndex - i + this.trail.length) % this.trail.length;
                    const point = this.trail[idx];
                    
                    if (!point) continue;

                    const progress = i / trailLength;
                    const trailOpacity = opacity * (1 - progress) * 0.6;
                    const trailSize = this.size * (1 - progress * 0.5);

                    if (trailSize < 0.1) continue;

                    const gradient = ctx.createRadialGradient(
                        point.x, point.y, 0,
                        point.x, point.y, trailSize * 4
                    );
                    gradient.addColorStop(0, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${trailOpacity})`);
                    gradient.addColorStop(1, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 0)`);

                    ctx.beginPath();
                    ctx.arc(point.x, point.y, trailSize * 4, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                }

                // ç»˜åˆ¶å½—æ˜Ÿæ ¸å¿ƒ
                const coreGradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, this.size * 8
                );
                coreGradient.addColorStop(0, `rgba(255, 255, 255, ${opacity})`);
                coreGradient.addColorStop(0.2, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${opacity * 0.8})`);
                coreGradient.addColorStop(1, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 0)`);

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 8, 0, Math.PI * 2);
                ctx.fillStyle = coreGradient;
                ctx.fill();

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                ctx.fill();
            }

            // æ¸…ç†æ–¹æ³•ï¼Œé‡Šæ”¾èµ„æº
            dispose() {
                this.trail = null;
            }
        }

        const stars = [];
        const comets = [];

        // åˆå§‹åŒ–æ˜Ÿæ˜Ÿ
        for (let i = 0; i < config.starCount; i++) {
            stars.push(new Star(canvas.width, canvas.height));
        }

        function spawnComet() {
            if (comets.length < config.maxComets && Math.random() < config.cometSpawnChance) {
                comets.push(new Comet(canvas.width, canvas.height));
            }
        }

        const cometTimer = setInterval(spawnComet, config.cometSpawnInterval);
        resourceManager.addTimer(cometTimer);

        // å¯åŠ¨æ€§èƒ½ç›‘æ§
        perfManager.start();

        // ç«‹å³æ¸²æŸ“ç¬¬ä¸€å¸§
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        stars.forEach(star => star.draw());

        let lastFrameTime = performance.now();

        function animate() {
            perfManager.update();
            
            const now = performance.now();
            const deltaTime = now - lastFrameTime;
            lastFrameTime = now;

            // å¦‚æœå¸§æ—¶é—´è¿‡é•¿ï¼ˆ>50msï¼‰ï¼Œè·³è¿‡å¤æ‚æ¸²æŸ“
            const skipComplexRender = deltaTime > 50;
            const reduceQuality = perfManager.shouldReduceQuality() || skipComplexRender;

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // æ›´æ–°å’Œç»˜åˆ¶æ˜Ÿæ˜Ÿ
            stars.forEach(star => {
                star.update();
                star.draw(reduceQuality);
            });

            // æ›´æ–°å’Œç»˜åˆ¶å½—æ˜Ÿ
            for (let i = comets.length - 1; i >= 0; i--) {
                const alive = comets[i].update();
                if (alive) {
                    comets[i].draw(reduceQuality);
                } else {
                    // æ¸…ç†å½—æ˜Ÿå¯¹è±¡
                    comets[i].dispose();
                    comets.splice(i, 1);
                }
            }

            // æ›´æ–°æ€§èƒ½ä¿¡æ¯
            if (document.getElementById('perfInfo').style.display === 'block') {
                const fpsElement = document.getElementById('fps');
                fpsElement.textContent = perfManager.fps;
                
                // æ ¹æ®FPSæ”¹å˜é¢œè‰²
                if (perfManager.fps >= 50) {
                    fpsElement.className = 'perf-good';
                } else if (perfManager.fps >= 30) {
                    fpsElement.className = 'perf-warning';
                } else {
                    fpsElement.style.color = '#f00';
                }
                
                document.getElementById('starCount').textContent = stars.length;
                document.getElementById('cometCount').textContent = comets.length;
            }

            const frame = requestAnimationFrame(animate);
            resourceManager.setAnimationFrame(frame);
        }

        animate();

        // çª—å£å¤§å°æ”¹å˜
        const resizeHandler = () => {
            setCanvasSize();
            stars.forEach(star => {
                star.canvasWidth = canvas.width;
                star.canvasHeight = canvas.height;
            });
            comets.forEach(comet => {
                comet.canvasWidth = canvas.width;
                comet.canvasHeight = canvas.height;
            });
        };
        resourceManager.addEventListener(window, 'resize', resizeHandler);

        // é¼ æ ‡äº¤äº’æ•ˆæœ
        const mouseMoveHandler = (e) => {
            const textElement = document.querySelector('#waterText');
            const rect = textElement.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            const deltaX = (e.clientX - centerX) * 0.008;
            const deltaY = (e.clientY - centerY) * 0.008;
            
            textElement.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
        };
        resourceManager.addEventListener(document, 'mousemove', mouseMoveHandler);

        // é”®ç›˜å¿«æ·é”®
        resourceManager.addEventListener(document, 'keydown', (e) => {
            if (e.key === 'F12') {
                e.preventDefault();
                const perfInfo = document.getElementById('perfInfo');
                perfInfo.style.display = perfInfo.style.display === 'none' ? 'block' : 'none';
            }
        });

        // é¡µé¢å¯è§æ€§å˜åŒ–
        resourceManager.addEventListener(document, 'visibilitychange', () => {
            if (document.hidden) {
                console.log('é¡µé¢éšè—ï¼ŒåŠ¨ç”»ç»§ç»­è¿è¡Œï¼ˆå¯é€‰æ‹©æš‚åœï¼‰');
            } else {
                console.log('é¡µé¢æ˜¾ç¤º');
            }
        });

        // é¡µé¢å¸è½½æ—¶æ¸…ç†
        resourceManager.addEventListener(window, 'beforeunload', () => {
            perfManager.cleanup();
            resourceManager.cleanup();
            
            // æ¸…ç†æ‰€æœ‰å½—æ˜Ÿå¯¹è±¡
            comets.forEach(comet => comet.dispose());
            comets.length = 0;
            stars.length = 0;
            
            gradientCache.clear();
        });

        // ç›‘å¬å†…å­˜å‹åŠ›ï¼ˆå®éªŒæ€§APIï¼‰
        if ('memory' in performance) {
            const memoryCheckTimer = setInterval(() => {
                const memUsage = performance.memory.usedJSHeapSize / performance.memory.jsHeapSizeLimit;
                if (memUsage > 0.9) {
                    console.warn('å†…å­˜ä½¿ç”¨è¿‡é«˜:', (memUsage * 100).toFixed(2) + '%');
                }
            }, 10000);
            resourceManager.addTimer(memoryCheckTimer);
        }

        console.log('ğŸ¨ åŠ¨æ€å£çº¸åˆå§‹åŒ–å®Œæˆ');
        console.log('ğŸ“Š æŒ‰ F12 æ˜¾ç¤ºæ€§èƒ½ç›‘æ§');
    </script>
</body>
</html>